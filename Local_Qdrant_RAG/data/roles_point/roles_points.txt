AI
API
APScheduler
AUC-ROC
AWS
AWS SageMaker
Accelerate training using GPU support and CUDA integration using PyTorch.
Activate project-specific environments for clean setups using venv.
Add custom annotations to segments using X-Ray.
Add interactivity to server-rendered HTML with minimal JS using HTMX.
Add retries, timeouts, and parallel steps in state machines using key Step Functions.
Add sessions, templates, and middleware support using Flask.
Add static type checking for Python functions and variables using mypy.
Add user auth and session handling in apps using Flask.
Add version control, tests, and documentation for key DBT models.
Aggregate values for insights during transformation step.
Airflow
Alert on key suspicious or critical events in log data.
Allow key access to internal or SaaS apps via SAML.
Analyze CloudTrail and ALB logs stored in S3 using Athena.
Analyze key bottlenecks and slow requests in APM view.
Analyze key bugs, smells, and flaws via static checks.
Analyze massive datasets in BigData using PySpark ETL.
Analyze patterns in datasets with Data Analytics methods.
Analyze structured datasets via Pandas in analytics tools.
Analyze unstructured logs with data mining techniques.
Annotate code using Python 3 type hints and validate using mypy.
Apache
Apache Flink
Apache Hudi
Applied GraphQL with Neo4j for real-time graph data access.
Applied Python loops and conditions for data processing.
Applied regex with Python's re module to extract patterns.
Apply AI techniques for automation and predictions.
Apply EDA and feature selection in data science models.
Apply ML in fraud, recommendation, or demand systems.
Apply PyTorch in vision, NLP, and time-series ML tasks.
Apply RNN for time series forecasting of sales.
Apply Tokenization for BERT input preprocessing.
Apply Unsupervised Learning for pattern discovery in data.
Apply Unsupervised Learning to drive autonomous behavior.
Apply XGBoost in classification and ranking problems.
Apply access control, masking, and roles for data governance using key Snowflake.
Apply cleanup policies in Nexus to retain key recent builds.
Apply clustering or classification during data mining tasks.
Apply data transformations using Python for modeling.
Apply encoding and binning in Python preprocessing.
Apply filtering, slicing, and reshaping techniques using NumPy.
Apply key access control and SAST tools in GitLab.
Apply key enrichment and tagging to log data in Logstash.
Apply key filters and format conversion using Fluentd.
Apply key parsing and text analysis pipelines in Elastic.
Apply key quality gates to enforce code best practices.
Apply lifecycle rules and tags in ECR for cleanup.
Apply multi-class classification models using Python.
Apply random forest for fraud and churn prediction models.
Apply row-level security and filters for users in QuickSight.
Apply transformation rules during data transfer using DMS.
Apply versioning and lifecycle policies to manage cost using Data Lake.
Architect
Artificial Intelligence
Assign IAM roles securely to ECS tasks and containers.
Athena
Audit Logs
Audit and rotate credentials and access keys using IAM.
Audit and upgrade packages to fix vulnerabilities using pip.
Audit downloads and check vulnerabilities via PyPI.
Audit for known security issues in dependencies using pipenv.
Audit key authentication attempts and logs in SAML.
Audit key login history and session rules in SSO tools.
Audit key logs and rotate secrets securely using Vault CLI.
Audit key secret usage via CloudTrail in AWS monitoring.
Aurora
Authenticate users with external identity providers using OAuth.
Auto-discover schema from S3 or JDBC using key Glue Crawlers.
Auto-format Python code with opinionated PEP8 rules using black.
Auto-generate lineage graphs and catalogs using key DBT CLI or UI.
Auto-remediate key violations using Lambda or SSM tools.
Auto-scale pipelines based on workload and input size using key Dataflow.
Automate AWS resource management using Python and Boto3.
Automate Backpropagation in deep learning libraries.
Automate Docker builds and deployments with GitLab CI.
Automate ETL workflows using Bash and Shell script.
Automate backups, monitoring, and failover setup using RDS.
Automate browsers for scraping, testing, or interaction using Selenium.
Automate continuous integration pipelines for any project using Jenkins.
Automate cross-browser interactions and testing using Playwright.
Automate data loads using Airflow in data engineering.
Automate data testing in ETL pipelines with Great Expectations checkpoints.
Automate dependency setup in CI/CD pipelines using pip.
Automate feature creation in AI pipelines efficiently.
Automate key actions with Butler rules in Trello cards.
Automate key actions with CloudWatch + Lambda or SNS.
Automate key builds and deploys via GitHub Actions.
Automate key infra using ARM or Bicep templates in Azure.
Automate key infra with Deployment Manager or Terraform.
Automate key provisioning via CodePipeline integration.
Automate key secrets rotation logic via AWS Secrets Manager.
Automate model training and deployment using CI/CD and MLOps stacks.
Automate repetitive tasks like file processing or cleanup using Python scripts.
Automated CI/CD pipelines integrated with OpenShift for faster delivery.
Automated infrastructure provisioning using IaC with Terraform.
Automated testing workflows using CI/CD pipelines with Python scripts.
Automatically resolve and lock dependencies using pipenv.
Automation
Avoid Overfitting by using regularization in models.
Azure
Azure ML
Azure Monitor
BERT
Bash
BeautifulSoup
Benchmark ideas on Kaggle datasets for ML learning.
Big Data
BigData
BigQuery
Bitbucket
Bokeh
Boto3
Build AI models for NLP and vision using TensorFlow.
Build ETL pipelines for batch and streaming using PySpark.
Build KPIs and reports using Pandas for Data Analytics.
Build ML pipelines using Python in data science projects.
Build RAG (Retrieval-Augmented Generation) pipelines with vector search.
Build RESTful routes and handle JSON data using Flask.
Build and manage SQL data models using dbt framework.
Build and train deep learning models with flexibility using PyTorch.
Build attention-based models for sequence and time-series predictions.
Build backend services and Spark jobs on EMR using Java.
Build classifiers using Python like logistic regression.
Build dashboards with interactive charts and graphs using Plotly.
Build data validation layers in data engineering stack.
Build deep learning models for training and inference using TensorFlow.
Build dynamic backends, static sites, and cron jobs in one place using Render.
Build dynamic single-page applications with component architecture using ReactJS.
Build explainable AI systems using SHAP, LIME, or Captum libraries.
Build fault-tolerant jobs using Hadoop Yarn features.
Build full-stack web apps using built-in ORM, views, and templates using Django.
Build intelligent systems using Supervised Learning logic.
Build key CI/CD pipelines using Azure DevOps and Boards.
Build key dashboards to visualize trends in AWS metrics.
Build key dashboards with Kibana using Elasticsearch data.
Build key pipelines for scalable log handling using LS.
Build low-latency real-time stream processing jobs using Apache Flink.
Build models using Supervised Learning on labeled data.
Build modular and type-safe ETL pipelines using key Dagster framework.
Build preprocessing pipelines and transformers using scikit-learn.
Build reproducible ML workflows with pipeline orchestration using key Vertex AI.
Build reusable PySpark utilities for partitioning and schema inference.
Build reusable UI components with templating features using Jinja2.
Build robust classifiers using random forest in Python.
Build scalable pipelines for BigData with Spark or Hadoop.
Build scalable, event-driven web crawlers using Scrapy.
Build tree-based models on tabular data using XGBoost.
Build, run, and debug isolated containers using Docker CLI using Docker.
Build, up, down, and restart containers easily using Docker Compose.
Built Docker images and deployed them through OpenShift clusters.
Built GraphQL APIs using FastAPI for smooth data access.
Built Python classes using OOP concepts like inheritance.
Built a snowflake data model to reduce data redundancy.
Built backend APIs and data processing in NodeJS
Built custom filters and scoring logic inside vectordb applications.
Built deployment scripts using Python for CI/CD pipelines in Jenkins.
Built lightweight RAG pipeline using vectordb Chroma and OpenAI.
Built reusable Python modules to enhance code readability.
Built scalable microservices as a backend developer with Django and Flask.
Built semantic search pipelines using vectordb like Weaviate and Qdrant.
Built semantic search systems using Qdrant and sentence-transformers.
Built text generation tools using Generative AI with Python and transformers.
Built vector search apps using Weaviate and OpenAI embeddings.
CDC
CDK
CI/CD
Capture screenshots, traces, and logs for debugging using Playwright.
Catch errors and improve code safety with type annotations using pyright.
Catch logical and stylistic issues during development using pylint.
Catch type mismatches and invalid operations early using mypy.
Celery
Centralize key authentication across all enterprise apps.
Centralize logs from Glue, Lambda, and apps using CloudWatch Logs.
Chain CLI commands using pipes, loops, and conditionals using Bash.
Chain multiple jobs using Workflows and Triggers in key Glue.
Chat in key channels or DMs for real-time team updates.
Check and handle disk usage or free space with `shutil.disk_usage()` using shutil.
Check file existence, file type, and size using pathlib.
Chroma
CircleCI
Classification
Clean and format raw web content before storage using BeautifulSoup.
Clean noisy and corrupt data using Python cleaning tools.
Clean raw data with Python preprocessing techniques.
Clean, filter, and transform structured data using Pandas.
Click buttons, fill forms, and simulate user input using Selenium.
Cloud Functions
CloudFormation
CloudTrail
CloudWatch
CloudWatch Logs
CloudWatch Metrics
Co-author docs and tasks in key Teams wikis or boards.
Collaborate in key Teams channels for dev and ops work.
Collaborate using key checklists, labels, and members.
Collaborate via key forks, comments, and reviews daily.
Collaborated with teams to design the logical data model.
Collect key logs from multiple sources using Fluentd core.
Collect key logs, metrics, and events from AWS services.
Collect key metrics and logs from Azure services easily.
Collect key traces, logs, metrics in a single Datadog view.
Combine with Selenium for key UI test automation flows.
Combine with isort and flake8 for full code quality enforcement using black.
Combine with pre-commit hooks for automatic lint checks using flake8.
Combine with requests or Selenium for complete scraping workflows using BeautifulSoup.
Config
Configure IAM roles, policies, and service permissions using AWS.
Configure SSL, rate-limiting, and load balancing using Nginx.
Configure autoscaling, load balancing, and rolling updates using Kubernetes.
Configure jobs using declarative Jenkinsfiles or UI using Jenkins.
Configure read/write capacity and autoscaling in DynamoDB.
Configure secure MSK clusters with encryption and IAM roles.
Configure timeout, workers, and bind settings easily using Gunicorn.
Configure virtual hosts, SSL certificates, and rewrite rules using Apache.
Configured security policies and access controls in OpenShift projects.
Connect BigQuery to BI dashboards or ML models using key BigQuery.
Connect CloudTrail with GuardDuty for threat detection.
Connect CloudWatch Metrics with EventBridge for automation.
Connect Flask to databases using SQLAlchemy or ORM tools.
Connect GitHub or Bitbucket for automatic pipeline triggers using CircleCI.
Connect GitHub/GitLab repos for instant deployment using Vercel.
Connect Oracle to AWS Glue using JDBC drivers.
Connect SNS with CloudWatch and EventBridge alerts.
Connect SQL Server to Glue or DMS for AWS integration.
Connect Teams with key tools like GitHub or Azure DevOps.
Connect key tools like GitHub, Jira, Opsgenie to Slack.
Connect to APIs, databases, or external tools for automation using Python scripts.
Connect to Redshift, S3, RDS, or DynamoDB via key Glue jobs.
Connected GitHub Actions with CI/CD pipelines to streamline code pushes.
Connected GraphQL with databases like PostgreSQL or MongoDB.
Connected LLMs with vectordb for real-time question-answering.
Connected frontend apps to RESTful API Python backends.
Connected frontend apps to RESTful Python backends.
Consume APIs from Django/Flask/FastAPI backends using React.
Consume REST APIs from Django/FastAPI backends using Vue.
Consume and transform streaming events from multiple sources using Kafka.
Containerize Python and ML apps for consistent deployment using Docker.
Containerize apps into lightweight, portable environments using Docker.
Control access to visuals using IAM and SSO in QuickSight.
Control access using IAM roles for ECR repositories.
Control key access via IAM policies and Secrets Manager.
Control logic with conditions and loops in templates using Jinja2.
Control repository access with Nexus permissions and roles.
Control team access to repos in JFrog Artifactory setup.
Convert CDK code into CloudFormation templates easily.
Convert columns and apply custom functions using Pandas.
Convert large models to ONNX or TensorRT for faster inference.
Convert models to ONNX from PyTorch, TensorFlow, or sklearn.
Copy, move, and delete files or directories reliably using shutil.
Correlate X-Ray traces with logs via request IDs.
Create ETL jobs in Python for data engineering tasks.
Create and deploy production-ready feature pipelines using Tecton.
Create and manage SQL views, indexes, and stored procedures for efficient database operations.
Create and manage feature groups for training/inference using SageMaker Feature Store.
Create and manipulate arrays, matrices, and tensors using NumPy.
Create and orchestrate data pipelines across cloud/on-prem using Data Factory.
Create batch and streaming data pipelines with Apache Beam using key Dataflow.
Create compressed archives (zip/tar) for backup or transfer using shutil.
Create cross-language environments for ML and analytics using conda.
Create custom DAGs for complex data workflows using Dask.
Create custom dashboards using CloudWatch Metrics insights.
Create dashboards and UI endpoints quickly using Flask.
Create dashboards on Redshift, S3, and RDS data using QuickSight.
Create interactive UIs and SPAs with component-based design using Vue.
Create interactive dashboards and charts for analytics using Bokeh.
Create isolated Python environments using venv.
Create isolated environments across Python versions using virtualenv.
Create isolated environments using Pipfile and Pipfile.lock using pipenv.
Create key alerts and dashboards for resource health.
Create key dashboards from real-time data sources in Grafana.
Create log dashboards for visibility using CloudWatch Logs.
Create modular routes using Blueprints and Flask-Restful using Flask.
Create multi-region trails for full coverage in CloudTrail.
Create partitioned and bucketed tables for speed in HiveQL.
Create reproducible training workflows with pipelines using Azure ML.
Create scalable ETL jobs using PySpark or Python Shell in key Glue.
Create scheduled queries and materialized views for reports using key BigQuery.
Create setup scripts for provisioning environments using Bash.
Create static and interactive plots for data visualization using Plotly.
Create static plots, bar charts, and line graphs using matplotlib.
Create statistical plots like bar, box, and violin charts using seaborn.
Create stored procedures and packages using Oracle PL/SQL.
Create tables and define schema using SQL DDL commands.
Create useful metrics during feature engineering phase.
Create, remove, or rename directories and files using os.
Created Python generators with yield for memory efficiency.
Created RESTful API routes for CRUD operations in Flask.
Created RESTful routes for CRUD operations in Flask.
Created and queried nodes and relationships in GraphDB Neo4j.
Created command-line tools using Python and argparse.
Created content generation pipelines using Generative AI models.
Created dynamic web pages using ReactJS components.
Created flexible Python functions using *args and **kwargs.
Created star schema data model for fast analytical reporting.
Customize color palettes and themes for better visuals using seaborn.
Customize rules using configuration files (e.g., .flake8) using flake8.
Customize titles, labels, legends, and styles using matplotlib.
Customize tooltips, hover actions, and themes for better UX using Plotly.
Customize tooltips, zoom, and pan features easily using Bokeh.
DBT
DMS
Dagster
Dask
Data Analytics
Data Engineering
Data Factory
Data Ingestion
Data Lake
Data Modeling
Data Science
Datadog
Dataflow
Debug and tune complex SQL joins and aggregations for performance optimization.
Debug application logs and container states using Docker.
Debug local and remote build issues using environment tools.
Debug local development environments efficiently using Docker Compose.
Deep Learning
Define AWS infrastructure using code with CDK.
Define CI/CD pipelines using `.gitlab-ci.yml` configuration using GitLab CI.
Define and manage build pipelines in `config.yml` using CircleCI.
Define async ORM models and relationships for SQL databases using Tortoise ORM.
Define cloud infrastructure using IAC tools for deployment.
Define key AWS stacks using YAML/JSON templates in CFN.
Define key SLOs, SLAs, and alerts using New Relic tools.
Define key policies for K8s, APIs, or Terraform in Rego.
Define key rules to ensure compliance via AWS Config.
Define least-privilege access policies using IAM roles.
Define lifecycle scripts like test or build in npm.
Define metadata and scripts via `pyproject.toml` using Poetry.
Define models and relationships with declarative syntax using SQLAlchemy.
Define multi-container applications using YAML syntax using Docker Compose.
Define multi-container apps (e.g., web, db, cache) using Docker Compose.
Defined tech stack and best practices for project architecture.
Delta Lake
Deploy AI workloads on GPU/TPU using TorchServe or TF Serving.
Deploy DAGs securely on MWAA using managed Airflow services.
Deploy Flask apps on cloud services like EC2 and ECS.
Deploy Flask or Django apps reliably using Gunicorn.
Deploy ML models using Flask or FastAPI services.
Deploy ML/AI models as APIs using FastAPI or Flask in production.
Deploy Python web apps with zero infrastructure setup using Heroku.
Deploy apps with Uvicorn and Docker in production using FastAPI.
Deploy async APIs with low latency and memory usage using Uvicorn.
Deploy data dashboards via Bokeh Server or standalone HTML using Bokeh.
Deploy distributed computations and monitor via dashboard using Dask.
Deploy endpoints on AWS SageMaker with auto-scaling.
Deploy frontend frameworks like React, Next.js, Vue using Vercel.
Deploy full-stack apps without managing infrastructure using Render.
Deploy key DaemonSets in Kubernetes using Fluent Bit.
Deploy key apps with Azure Functions, App Services, or VMs.
Deploy key workloads using GKE, Cloud Run, or App Engine.
Deploy models as endpoints with autoscaling and monitoring using Azure ML.
Deploy models to production using TensorFlow Serving or TF Lite.
Deploy models with TensorFlow Serving and TensorFlow Lite using TensorFlow.
Deploy on cloud platforms like Heroku and AWS using Flask.
Deploy pipelines on ECS, Kubernetes, or Docker using key Dagster.
Deploy production models with TorchScript or ONNX using PyTorch.
Deploy production-ready ML pipelines using PyTorch modules.
Deploy resources via CI/CD with automation in deployment.
Deploy reusable jobs with parameterized templates using key Dataflow.
Deploy scalable Kubernetes workloads on AWS using EKS.
Deploy small, fast inference models cross-platform using ONNX.
Deploy stacks via CI/CD pipelines using CDK integration.
Deploy via ZIP, container image, or CDK for automation using Lambda.
Deploy, scale, and manage containerized applications using Kubernetes.
Deployed Generative AI models on cloud using Docker and Python.
Deployed and tested vectordb containers locally for AI prototypes.
Deployed microservices using OpenShift for container orchestration.
Design AI pipelines for real-time decision systems.
Design CNNs using Neural Network for image tasks.
Design ETL pipelines with RDS as source or target system.
Design access patterns and key structure in DynamoDB.
Design and optimize schemas and queries using Amazon Redshift.
Design and train neural networks for various tasks using TensorFlow.
Design data lakes and tables in data engineering flow.
Design decision logic via Reinforcement Learning feedback.
Design modular AI pipelines supporting retraining and CI/CD automation.
Design scalable data lakes using S3 for big data analytics.
Design scalable model inference APIs with batching and queuing logic.
Design tables, views, and procedures using SQL Server.
Designed GraphQL schemas for flexible frontend queries.
Designed RESTful APIs as a backend developer using Python and FastAPI.
Designed a normalized data model for efficient storage and joins.
Designed and developed RESTful API using Python and FastAPI.
Designed and developed RESTful using Python and FastAPI.
Designed system architecture for scalable and secure web apps.
Detect Underfitting with poor training and test accuracy.
Detect key drift and track stack events in CloudFormation.
Detect names and locations using NER techniques.
Detect unused variables, imports, and indentation issues using flake8.
DevOps
Develop Kafka producers and consumers in Java for streaming.
Develop async REST APIs with auto-generated Swagger UI using FastAPI.
Develop deep learning models for training and testing using PyTorch.
Develop lightweight APIs for ML or data tasks using Flask.
Develop lightweight web APIs and services using Flask.
Develop scalable data ingestion frameworks for structured/unstructured data.
Develop secure REST APIs with Django REST Framework using Django.
Developed Python scripts to automate daily tasks and workflows.
Developed RAG pipelines with OpenAI and Qdrant backend.
Developed chatbots powered by Generative AI using LangChain.
Developed fast search APIs powered by vectordb and HuggingFace models.
Diagnose failures using logs in environment specific layers.
Distribute JARs globally using Maven Central access.
Django
Django ORM
Docker
Docker Compose
Docker Hub
Documented RESTful API using Swagger and OpenAPI.
Documented RESTful using Swagger and OpenAPI.
Documented data model changes for team-wide understanding.
Download Kaggle datasets via API or GUI for projects.
Drive business decisions with Pandas-based analytics.
DynamoDB
ECR
ECS
EKS
EMR
ERP
ERPNext
ETL
Easily iterate over directory contents with `Path.iterdir()` using pathlib.
Elasticsearch
Embed Bokeh plots into Flask or Django web apps using Bokeh.
Embed key dashboards into portals or internal status pages.
Enable ACID operations and table snapshots on data lakes using key Iceberg.
Enable AJAX form submissions and updates using HTMX.
Enable HTTP/2 and WebSocket support natively using Uvicorn.
Enable TTL in DynamoDB to auto-expire unused data items.
Enable auto or manual key rotation in AWS using KMS.
Enable cross-account access for shared CloudWatch Logs.
Enable fast deploys via regional Google GCR setup.
Enable health checks and failover routing in production using Nginx.
Enable high throughput ingestion by scaling shards dynamically using Kinesis.
Enable key KMS encryption for secrets at rest in K8s.
Enable key enterprise SSO using XML-based SAML flows.
Enable key federated identity via OpenID Connect auth.
Enable key log unification in cloud-native platforms.
Enable key single sign-on via OAuth, SAML, or OpenID.
Enable multi-AZ deployment in RDS for high availability.
Enable near real-time data replication with DMS tasks.
Enable schema evolution and partitioning for performance using Data Lake.
Enable serverless functions for backend APIs using Vercel.
Enable strict or lenient checking modes for gradual adoption using pyright.
Enable upserts and incremental loads in data lakes using key Apache Hudi.
Encode, scale, or bin data in transformation workflows.
Encrypt and move petabyte-scale data offline with Snowball.
Encrypt data at rest in S3, RDS, and Redshift using KMS.
Encrypt key secrets using AWS/GCP KMS, age with SOPS tool.
Enforce Python style rules and PEP8 compliance using flake8.
Enforce key access policies with HCL and Vault ACLs setup.
Enforce key code reviews using PR policies in Bitbucket.
Enforce key rules using OPA with Gatekeeper or Envoy.
Enforce key security using branch rules and secrets scan.
Enforce naming conventions and docstring checks using pylint.
Enforce package naming and versioning in Maven Central.
Ensure compatibility across legacy and modern Python tools using virtualenv.
Ensure consistent builds across machines and clouds using Docker.
Ensure consistent code formatting across teams using black.
Ensure dev/prod parity with local container testing using Docker.
Ensure key test reproducibility with fresh containers.
Ensure modeling readiness with proper data cleaning.
Ensure performance using thread-safe design in Java code.
Ensure reproducible builds using `poetry.lock` using Poetry.
Ensure safety and maintainability in large projects using mypy.
Ensure security by escaping user content using Jinja2.
Ensured performance and reliability in system architecture.
Evaluate classifiers via F1-score, ROC in classification.
Evaluate machine learning models using precision/recall.
Evaluate model accuracy and precision using scikit-learn tools.
Evaluate models using precision, recall, F1-score, and AUC-ROC.
Evaluate random forest using accuracy and confusion matrix.
Execute asynchronous tasks across distributed workers using Celery.
Execute shell commands with subprocess or system calls using os.
Exeption handling in Python using try-except-finally blocks.
Experiment with models on Kaggle datasets in Python.
Explore datasets using describe, info, and head in Python.
Export PyTorch models to TorchScript for deployment tasks.
Export XGBoost models for APIs or batch inference tasks.
Export and reproduce environments via `environment.yml` using conda.
Export data to JSON, CSV, or databases using Scrapy.
Export key reports in HTML or XML for CI/CD tools use.
Export processed data to files or databases using Pandas.
Extract and clean structured data with pipelines using Scrapy.
Extract and transform data using SQL and PL/SQL in Oracle.
Extract patterns from large datasets using data mining tools.
Extract tags, attributes, and structured data for scraping using BeautifulSoup.
Facilitate ML collaboration and governance using Tecton.
FastAPI
FastAPI throttle
Feast
Filter and sort data using SQL WHERE, ORDER BY, and LIMIT.
Filter rows based on conditions and queries using Pandas.
Find performance bottlenecks with AWS X-Ray traces.
Fine-tune large language models (LLMs) on custom domain data.
Fine-tuned Generative AI models for specific domain tasks.
Fix Python code style issues automatically using autopep8.
Flask
Fluent Bit
Fluentd
Follow key Git workflows like trunk-based or Git Flow.
Format large legacy codebases with minimal manual changes using autopep8.
Freeze and share dependencies with `requirements.txt` using pip.
GCP
GPU
Generate business dashboards with Data Analytics tools.
Generate dynamic HTML for data dashboards using Mako.
Generate features from raw data via feature engineering.
Generate heatmaps, pair plots, and count plots for EDA using seaborn.
Generate key reports and test coverage stats via pytest.
Generate key sprint reports and velocity graphs in JIRA.
Generate lineage and docs automatically using dbt.
Generate schemas from models for DB migrations using Tortoise ORM.
Get process-related info like PID, CPU, and memory details using os.
Git
GitHub
GitLab
GitLab CI
Glue
Google GCR
Google Stackdriver
Grafana
GraphDB
GraphQL
Great Expectations
Group and summarize data using SQL GROUP BY and HAVING.
Gunicorn
HTMX
Handle JSON and evolving schemas in semi-structured data using PySpark.
Handle broken or nested HTML with various built-in parsers using BeautifulSoup.
Handle class imbalance with scale_pos_weight in XGBoost.
Handle database schema changes with migrations using Django ORM.
Handle dynamic JavaScript-rendered pages reliably using Selenium.
Handle imbalanced datasets in Python classification.
Handle key incidents via alerts, ops bots, and war rooms.
Handle key token refresh and revocation in OIDC setup.
Handle migrations with Alembic integration using SQLAlchemy.
Handle missing values and data types efficiently using Pandas.
Handle retries and exceptions effectively using Boto3 logic.
Handle retries, task chaining, and error recovery gracefully using Celery.
Handle short ETL tasks and pre/post-processing steps using key Cloud Functions.
Handle token expiration, refresh, and revocation securely using JWT.
Handle windowing, event-time processing, and watermarking using key Dataflow.
Handled CSV/JSON files using Python read/write functions.
Handled database operations as a backend developer using SQL and ORM tools.
Handled testcontainers for database integration unit testing
HashiCorp Vault
Haystack
Helm
Heroku
HiveQL
Host and share Docker images with teams on Docker Hub.
Host internal artifacts securely with Nexus in DevOps pipelines.
Host key Git repositories inside the Atlassian suite.
Host key codebases and branches using GitHub repos.
Hyperparameter
IAC
IAM
Iceberg
Implement ABAC to control access dynamically using IAM.
Implement Lambda consumers and custom apps for real-time use cases using Kinesis.
Implement MLOps for automated CI/CD of ML pipeline.
Implement OAuth 2.0 flows for login with Google, GitHub, etc. using OAuth.
Implement S3 lifecycle policies to reduce storage cost.
Implement advanced SQL techniques like window functions, CTEs, and subqueries.
Implement authentication and permissions with built-in support using Django.
Implement distributed locks for task coordination using Redis backend tools.
Implement mathematical and statistical functions using NumPy.
Implement model versioning and experiment tracking using MLflow.
Implement multi-modal AI combining text, image, and tabular data.
Implement rate limiting using FastAPI throttle libraries using FastAPI throttle.
Implement read replicas for scaling read queries in RDS.
Implement rule mining to find hidden patterns in data.
Implement secure OAuth2/JWT authentication using FastAPI.
Implement user roles, scopes, and permissions inside access tokens using JWT.
Implement zero-shot/few-shot inference using foundation models.
Implemented Python iterators to loop through custom objects.
Implemented error handling in RESTful API services for reliability.
Implemented error handling in RESTful services for reliability.
Implemented fast document indexing and retrieval using weaviate REST APIs.
Implemented local semantic search using vectordb Chroma for prototyping.
Implemented scalable data model for handling big data.
Improve key security and login experience via SSO.
Improve or integrate with ERP tools like Odoo or ERPNext
Improve performance with partitioning and bookmarks in key Glue.
Improve query speed using GSIs and LSIs in DynamoDB.
Improve robot pathing using Reinforcement Learning rewards.
Improved API performance using GraphQL resolvers and query optimizations.
Improved deployment speed and consistency using IaC tools.
Improved performance and response times as a backend developer for APIs.
Index key logs, docs, and metrics for fast search in Elastic.
Indexed user and document vectors into vectordb for production search.
Ingest and buffer high-throughput real-time messages using Kafka.
Ingest and ship key logs to Elastic using Logstash config.
Ingest and store real-time events for analytics and ML using Kinesis.
Ingest and stream real-time data using Kafka APIs with MSK.
Ingest into S3 or GCS with Spark or Flink engines using key Apache Hudi.
Insert, update, and delete records using SQL DML commands.
Install and manage Python libraries efficiently using pip.
Install and manage scientific packages with optimized binaries using conda.
Install public or private packages using PyPI repo.
Install, upgrade, and rollback applications on K8s clusters using Helm.
Installed Python packages via pip, poetry and virtual environments.
Instrument key apps for distributed tracing via New Relic.
Integrate AI systems with messaging queues like Kafka or SQS.
Integrate APIs, ML models, and Firestore for lightweight compute using key Cloud Functions.
Integrate AWS services like S3 and Redshift using Airflow hooks.
Integrate Athena with Glue Catalog for schema management.
Integrate Azure ML with DevOps CI/CD for continuous training.
Integrate Boto3 scripts in CI/CD and data workflows easily.
Integrate Docker Compose with CI/CD tools for fast deployment testing using Docker Compose.
Integrate Docker into CI/CD pipelines for faster deployments using Docker.
Integrate EMR with S3, DynamoDB, and HDFS for data access.
Integrate GitLab with key cloud and K8s platforms.
Integrate Hadoop and Spark for hybrid ETL processes.
Integrate JFrog Artifactory with Jenkins for CI pipelines.
Integrate ML with analytics for smarter solutions.
Integrate OAuth into APIs with FastAPI, Django, or Flask using OAuth.
Integrate Plotly visualizations into web applications using Plotly.
Integrate SQLAlchemy for ORM and database operations using Flask.
Integrate Selenium for hybrid dynamic scraping tasks using Scrapy.
Integrate Snowball with on-prem storage for bulk data migration.
Integrate Tecton with ML model deployments like SageMaker using Tecton.
Integrate TorchScript models with APIs or custom logic.
Integrate easily with Django, Flask, or FastAPI apps using Celery.
Integrate key IdPs like Okta or Azure AD via SAML.
Integrate key Terraform steps in CI/CD deployment flows.
Integrate key logs with SIEM or ELK for deep analysis.
Integrate key logs with Security Hub and CloudTrail.
Integrate key pipelines from GitHub, Jenkins, or GitLab.
Integrate key policies into CI/CD and runtime checks.
Integrate key secrets with GitOps like Flux and ArgoCD.
Integrate key secrets with K8s, CI/CD flows using Vault.
Integrate key secrets with Vault or SOPS using K8s plug-ins.
Integrate key test flows into CI/CD pipelines with ease.
Integrate key workflows with Logic Apps or Automation.
Integrate models into admin, views, and serializers using Django ORM.
Integrate seamlessly with Apache Spark jobs using key Delta Lake.
Integrate source systems using JDBC, APIs, and flat file ingestion.
Integrate with Airbyte, dbt, and Snowflake in key Dagster workflows.
Integrate with BigQuery, Dataflow, and GCS pipelines using key Vertex AI.
Integrate with CI to enforce type safety in PRs using mypy.
Integrate with FastAPI for fully async backend operations using Tortoise ORM.
Integrate with Flask or FastAPI for backend APIs using SQLAlchemy.
Integrate with Flask, FastAPI, or standalone scripts using APScheduler.
Integrate with Git hooks or CI for code standardization using black.
Integrate with IDEs and CI/CD workflows for automation using pylint.
Integrate with Kafka, S3, and Kinesis for input/output using Apache Flink.
Integrate with Lambda for data-driven application workflows using Aurora.
Integrate with ML libraries like XGBoost and scikit-learn for training using Dask.
Integrate with OAuth2 flows for Google, GitHub logins using JWT.
Integrate with PostgreSQL, Redis, and other addons easily using Heroku.
Integrate with Pyramid and SQLAlchemy-based apps using Mako.
Integrate with Redis, BigQuery, and S3 for storage using Feast.
Integrate with black for seamless formatting pipelines using isort.
Integrate with key providers like Auth0 or Cognito APIs.
Integrate with pandas DataFrames for quick plotting using seaborn.
Integrate with pandas and NumPy for quick plotting using matplotlib.
Integrate with routing, forms, and UI libraries using React.
Integrate with text editors for real-time PEP8 fixes using autopep8.
Integrated Generative AI into web apps using Python and FastAPI.
Integrated Neo4j GraphDB with Python web apps FastAPI.
Integrated Neo4j with Python apps using FastAPI.
Integrated Qdrant into FastAPI apps for vector-based retrieval.
Integrated REST APIs and backend services with ReactJS.
Integrated Weaviate with LangChain for RAG pipelines.
Integrated databases with RESTful endpoints using SQLAlchemy.
Integrated third-party services as a backend developer in Python projects.
Integrated vectordb Chroma with LangChain for document retrieval.
Integrated vectordb with RAG workflows for document retrieval.
JFrog Artifactory
JIRA
JWT
Java
JavaScript
Jenkins
Jinja2
Join S3 data with Redshift tables using Redshift Spectrum queries.
Join and analyze data across GCS, Bigtable, and external sources using key BigQuery.
Join and filter structured S3 data efficiently using HiveQL.
Join datasets across sources like MySQL, Kafka, and Hive using key Presto.
Join, filter, and group data quickly using Polars engine.
Join, resolve, and normalize file paths across platforms using pathlib.
KMS
Kafka
Kaggle datasets
Kibana
Kinesis
Kubernetes
Kubernetes Secrets
LLM
Lambda
LangChain
Leverage Hive metastore for schema resolution using key Presto.
Leverage parallel processing in BigData ETL workflows.
Leverage pretrained transformers in AI applications.
Leverage torchvision and torchaudio for image/audio tasks using PyTorch.
Leveraged vectordb Chroma in Streamlit apps for real-time text search.
Link Stackdriver to BigQuery and Functions for key insights.
Link key branches and commits to JIRA issues easily.
Link key tasks with Jira, Trello, and Confluence tools.
Link key tools like GitHub, Slack for DevOps workflows.
Load datasets with Pandas and NumPy for analysis.
Log key policy decisions and violations for auditing.
Log throttled requests for auditing and alerts using FastAPI throttle.
Logstash
Lower model latency and size for inference using ONNX.
ML
MLOps
MLflow
MSK
Maintain ACID compliance in data lakes for updates and deletes using key Delta Lake.
Maintain checkpoints for recovery using Spark Streaming.
Maintain consistency across training and production pipelines using SageMaker Feature Store.
Maintain feature freshness with streaming or scheduled updates using Tecton.
Maintain metadata catalogs and schema registries using Glue.
Mako
Manage Helm charts and manifests for apps using EKS.
Manage JavaScript packages easily using npm registry.
Manage Python dependencies efficiently via PyPI.
Manage access tokens, refresh tokens, and scopes securely using OAuth.
Manage all types of binaries using JFrog Artifactory repos.
Manage and serve ML features efficiently for online/offline use using Feast.
Manage application state with savepoints and checkpoints using Apache Flink.
Manage cron jobs and scheduled tasks using Shell script.
Manage custom key policies and grants securely via KMS.
Manage data models and schema changes via migrations using Django.
Manage dev, staging, and prod environments via configs in key DBT.
Manage environment variables and read/write system settings using os.
Manage external schemas via Glue Catalog in Redshift Spectrum.
Manage global state using Vuex or Pinia using Vue.
Manage key IAM roles and secrets securely in GCP apps.
Manage key code versions using branches and tags in Git.
Manage key index patterns and saved views in Kibana.
Manage key infra lifecycle with stacks and change sets.
Manage key source code, CI/CD, and projects in GitLab.
Manage key tasks using Trello boards and cards daily.
Manage key user access and roles via Grafana permissions.
Manage large tables with schema evolution and partitioning using key Iceberg.
Manage native dependencies and versions efficiently using conda.
Manage petabyte-scale data using BigData technologies.
Manage project dependencies and environments seamlessly using Poetry.
Manage schema updates and migrations efficiently using Aurora.
Manage service dependencies (e.g., web + db containers) using Docker Compose.
Manage table schemas via Hive metastore using HiveQL.
Manage task definitions and scaling policies in ECS.
Manage topics, partitions, and replication for scalability using Kafka.
Manage updates and rollbacks using stack policies in deployment.
Manage versioned releases for environments using Helm.
Managed application scaling and rollouts with OpenShift dashboard.
Managed authentication and authorization as a backend developer using JWT and OAuth.
Managed cloud resources efficiently through IaC scripts.
Manipulate rows, columns, and types in Python datasets.
Map key user roles and attributes in SAML assertions.
Materialize batch features into data warehouse stores using Feast.
Maven Central
Merge and join datasets for feature creation using Pandas.
Microsoft Teams
Migrate on-prem or cloud databases to AWS targets using DMS.
Minimize code review nitpicks by automating style using black.
Minimize key resource usage in embedded systems logging.
Mock key dependencies using `pytest-mock` plugin tool.
Model
Model scalable NoSQL tables using partition keys in DynamoDB.
Models
Monitor AI model drift and retrain pipelines automatically.
Monitor DynamoDB metrics using CloudWatch dashboards.
Monitor ECS service health and metrics via CloudWatch.
Monitor MSK broker health and consumer lag via CloudWatch.
Monitor Redis performance using CLI tools or dashboards using Redis backend tools.
Monitor Redshift performance via system tables and CloudWatch.
Monitor builds and test results from an interactive UI using CircleCI.
Monitor function logs and errors using Cloud Logging using key Cloud Functions.
Monitor job performance using Spark UI and logs in PySpark.
Monitor job runs, errors, and logs via key Dagster UI or CLI.
Monitor job status and failures via Flower dashboard using Celery.
Monitor key GCP apps and services via Stackdriver tools.
Monitor key VMs, K8s clusters, exporters with Prometheus.
Monitor key app performance and user metrics via New Relic.
Monitor key metrics, apps, and infra in one place via Datadog.
Monitor key resources with Azure Monitor and Log Analytics.
Monitor key user and system actions via Audit Logs daily.
Monitor license and usage stats in Maven Central.
Monitor logs and performance via Heroku dashboard using Heroku.
Monitor migration progress and logs via DMS dashboard.
Monitor model performance and data drift in production using key Vertex AI.
Monitor performance using TensorBoard for real-time insights using TensorFlow.
Monitor performance with AWR and OEM in Oracle.
Monitor pipelines and fault tolerance via Flink Dashboard using Apache Flink.
Monitor pods and nodes using built-in metrics or Prometheus using Kubernetes.
Monitor run history and metrics in AWS Console with key Step Functions.
Monitor service logs and health metrics via dashboard using Render.
Monitor slow queries and optimize indexes using RDS logs.
Monitor system resources and logs via Shell script tools.
Monitor with CloudWatch and secure using KMS using AWS.
Monitored containerized workloads using OpenShift logging and metrics.
Mount key secrets as env or volumes into K8s pods securely.
Move and transform data from structured and unstructured sources using Data Factory.
NER
NLP
Neo4j
Neural Network
New Relic
Nexus
Nginx
NoSQL
NodeJs
Normalize datasets for modeling in preprocessing stage.
NumPy
OAuth
OIDC
ONNX
ORM
Open Policy Agent (OPA)
OpenShift
Optimize EMR costs via spot instances and autoscaling features.
Optimize Model Training with batch size tuning.
Optimize Models Training with batch size tuning.
Optimize Spark Streaming memory and latency for efficiency.
Optimize Spectrum queries using Parquet or ORC file formats.
Optimize deep learning models using quantization and pruning.
Optimize memory usage in high-volume computations using NumPy.
Optimize performance via metadata caching and pruning using key Iceberg.
Optimize performance with Z-ordering and compaction using key Delta Lake.
Optimize performance with indexes and partitions in SQL Server.
Optimize performance with select_related and prefetch_related using Django ORM.
Optimize query performance with Aurora query plan insights.
Optimize training with GPU/TPU support using TensorFlow tools.
Optimize web traffic with caching and compression using Apache.
Optimized RESTful API performance for faster responses.
Optimized RESTful performance for faster responses.
Optimized data model fields for faster query performance.
Oracle
Orchestrate data pipelines using DAGs and tasks in Airflow.
Orchestrate serverless workflows across Lambda, Glue, SageMaker using key Step Functions.
Organize S3 data using partitions for faster query access.
Organize code with Flask Blueprints and middleware.
Override configuration for dev/test/prod environments using Docker Compose.
Override settings for different environments via `.env` files using Docker Compose.
Package Kubernetes resources into reusable Helm charts using Helm.
Pandas
Parallelize Pandas-style workflows across multiple cores or machines using Dask.
Parse and filter key logs at source with Fluent Bit.
Parse and navigate HTML/XML documents using BeautifulSoup.
Parse key structured/unstructured logs using filters in LS.
Parse logs, environment variables, and files using Bash.
Perform CRUD operations efficiently with awaitable methods using Tortoise ORM.
Perform CRUD operations using AWS SDK with DynamoDB tables.
Perform CRUD operations with Django models using Django ORM.
Perform Cross-validation during hyperparameter tuning.
Perform Model Training on large datasets for predictions.
Perform Models Training on large datasets for predictions.
Perform ORM-based queries for SQL databases using SQLAlchemy.
Perform OS-level tasks like listing directories and handling paths using os.
Perform SQL joins to combine data from multiple tables.
Perform Sentiment Analysis on customer reviews.
Perform data profiling with Pandas in analytics projects.
Perform data transformation directly in the warehouse using key Snowflake.
Perform groupby and aggregation operations using Pandas.
Perform homogeneous or heterogeneous DB migrations using DMS.
Perform interactive ad-hoc analysis using ANSI SQL using key Presto.
Perform linear algebra operations and decompositions using NumPy.
Perform numerical computations with multi-dimensional arrays using NumPy.
Perform static code analysis with detailed scores using pylint.
Persist job state in memory, SQLite, or Redis backends using APScheduler.
Playwright
Plotly
Poetry
Polars
Prepare model input with smart transformation logic.
Preprocess Kaggle datasets using Python pipelines.
Preserve file metadata like permissions or timestamps during copy using shutil.
Presto
Prevent dependency conflicts across projects using venv.
Prevent merge conflicts from unordered imports using isort.
Preview every pull request automatically using Vercel.
Process MSK streams using Spark, Flink, or AWS Lambda apps.
Process and route events with Kinesis Data Analytics and Firehose using Kinesis.
Process batch data at scale using Hadoop MapReduce.
Process structured/unstructured datasets via Python.
Profile datasets to detect anomalies and missing values.
Prometheus
Promote and track builds across stages using Artifactory.
Protect API endpoints from spamming or brute-force using FastAPI throttle.
Provide real-time access to features for model inference using Feast.
Provision and manage MySQL/PostgreSQL instances using RDS.
Provision infrastructure with EC2, S3, Lambda, and RDS using AWS.
Provision key cloud infra as code across providers in TF.
Proxy third-party libraries with Nexus for faster access.
Proxy traffic to app servers like Uvicorn or Gunicorn using Nginx.
Publish CI/CD build artifacts using Nexus for version control.
Publish Java packages using Maven Central repository.
Publish Python packages to PyPI via pip or Poetry.
Publish and subscribe to real-time events in microservices using Redis backend tools.
Publish packages to PyPI or private registries using Poetry.
Publish reusable modules using npm for JS projects.
Push Docker images securely to AWS ECR private repo.
Push Docker images to Google GCR for GCP services.
Push and pull container images from Docker Hub or ECR using Docker.
Push and pull images from public or private Docker Hub.
Push images to Docker Hub or ECR for reuse using Docker.
Push key metrics from short jobs using Prometheus gateway.
PyDeequ
PyPI
PySpark
PyTorch
Python
Python script
Qdrant
Queried top-K relevant results from vectordb using cosine similarity.
Query S3, HDFS, or Hive data directly without ingestion using key Presto.
Query S3-based external tables using Redshift Spectrum SQL.
Query datasets with Presto, Hive, or Trino engines using key Apache Hudi.
Query efficiently with Athena, Presto, or Trino using key Iceberg.
Query external S3 data using Redshift Spectrum seamlessly.
Query key insights using Log Analytics in Azure Monitor.
Query key logs and events with Lucene or KQL in Kibana.
Query key logs via Logs Insights for fast debugging.
Query key metrics with PromQL for custom dashboards setup.
Query large datasets on EMR and S3 using HiveQL scripts.
Query petabyte-scale datasets using SQL without managing infrastructure using key BigQuery.
Query structured data in S3 using SQL with Amazon Athena.
QuickSight
Quickly switch between multiple environments across projects using conda.
RAG
RDS
RNN
Raise key pull requests for collaborative dev in Git.
Random Forest
Rapidly prototype reactive interfaces with Django or Flask using HTMX.
React
ReactJS
Read and write data from S3 and Glue Catalog using PySpark.
Read and write file content with `Path.read_text()` or `write_text()` using pathlib.
Read/write CSV, Excel, Parquet, and SQL files using Pandas.
Read/write Parquet and Arrow formats efficiently using Polars.
Receive key CI/CD and alert notifications in Slack chat.
Recursively copy folder contents while preserving structure using shutil.
Redis
Redis backend tools
Redshift
Redshift Spectrum
Reinforcement Learning
Remove nulls, scale features during preprocessing steps.
Remove outliers and errors in data using Python cleaning.
Render
Render dynamic HTML templates in Flask, Django, or FastAPI using Jinja2.
Render templates with embedded Python expressions using Mako.
Replace Pandas in memory-heavy tasks using Polars.
Replicate bugs across staging and prod environment setups.
Replicate production-like setups on any machine using Docker Compose.
Resolve and debug package conflicts using pip.
Resolve key merge conflicts and run peer reviews in Git.
Restrict key secret access via RBAC roles in Kubernetes.
Reviewed code and guided team on clean architecture patterns.
Roll back or recover datasets with commit-based lineage using key Apache Hudi.
Route key logs to Elastic, Kafka, or cloud sinks via Fluentd.
Run Athena queries via SDK or connect to BI tools easily.
Run CI/CD workflows in containers or VMs using CircleCI.
Run Python code without provisioning servers using Lambda.
Run audits and fix security issues using npm tools.
Run automatically via pre-commit or IDE plugins using isort.
Run background jobs in threads or processes using APScheduler.
Run background tasks and integrate with DBs and queues using FastAPI.
Run browser tests in headless mode with Chrome or Firefox using Selenium.
Run build, test, and deploy stages in GitLab runners using GitLab CI.
Run containerized workloads using Fargate or EC2 in ECS.
Run data transformations in CI/CD pipelines using key DBT Cloud or Core.
Run dbt models as part of CI/CD data pipelines.
Run distributed Spark and Hive jobs using Amazon EMR clusters.
Run fast DataFrame operations on large data using Polars.
Run fast static type checks with minimal config using pyright.
Run flake8 in CI pipelines to maintain clean codebases using flake8.
Run headless browser tests in CI/CD pipelines using Playwright.
Run in production with Gunicorn + Uvicorn workers using Uvicorn.
Run isolated test environments quickly using Docker Compose.
Run key CI flows using GitLab runners and pipelines.
Run key CI/CD builds using Bitbucket Pipelines tool.
Run key CI/CD flows with Cloud Build and Artifact Registry.
Run key integration tests with real DB or MQ in tests.
Run key test cases via Maven, Gradle, or IDEs like IntelliJ.
Run key tests in CI/CD with live services via Docker.
Run local dev environments with hot reloading support using Docker Compose.
Run model inference in Python or C++ using TorchScript.
Run multiple worker processes for concurrency using Gunicorn.
Run scalable SQL queries on structured and semi-structured data using key Snowflake.
Run, stop, and inspect services locally using Docker CLI using Docker.
S3
SAML
SHAP
SNS
SOPS
SQL
SQL Server
SQLAlchemy
SSO
SageMaker Feature Store
Save plots to PNG, PDF, or SVG formats using matplotlib.
Scale apps globally with edge functions and CDN caching using Vercel.
Scale apps horizontally using dyno settings and metrics using Heroku.
Scale data processing on large datasets that exceed memory using Dask.
Scale pods and nodes automatically in EKS environments.
Scan container images for threats using AWS ECR.
Scan key codebases across Java, Python, JS, and more.
Schedule Python jobs with cron, interval, or date triggers using APScheduler.
Schedule and monitor ETL workflows using Data Factory.
Schedule and track jobs with logs and alerts using Airflow UI.
Schedule backups and jobs with SQL Server Agent.
Schedule backups and snapshot retention policies using Aurora.
Schedule report refreshes and email delivery via QuickSight.
Schedule snapshot backups and retention policies via RDS.
Schedule tasks using cron or Task Scheduler with logging using Python scripts.
Scrape JavaScript-heavy pages with fast execution using Playwright.
Scrape key app metrics and service stats using Prometheus.
Scrapy
Secrets Manager
Secure Aurora databases with IAM, VPC, and SSL connections.
Secure DynamoDB data using IAM roles and KMS encryption.
Secure Google GCR with IAM roles and service accounts.
Secure Oracle DB with roles, grants, and permissions.
Secure RDS access using IAM roles, VPC, and encryption.
Secure RESTful APIs through stateless token-based auth using JWT.
Secure Redshift data using IAM roles and encryption features.
Secure S3 data using server-side encryption and IAM policies.
Secure SNS topics with IAM and encryption settings.
Secure access with IAM and apply row-level permissions using key BigQuery.
Secure access with IAM, encryption, and audit logs using Data Lake.
Secure feature data with IAM and encryption using SageMaker Feature Store.
Secure key APIs using token-based auth via OIDC flows.
Secure key branches with permission and deployment rules.
Secure key data with Key Vault and role-based access.
Secure streaming pipeline using IAM, SSL, and SASL with Kafka.
Secure with IAM and isolate environments per function using key Cloud Functions.
Secure workflows using IAM roles and policies in key Step Functions.
Secure workloads using IAM roles for service accounts in EKS.
Secured RESTful API services with JWT-based authentication.
Secured RESTful services with JWT-based authentication.
Selenium
Send CloudTrail logs to S3 and CloudWatch for analysis.
Send alerts via email, SMS, or Lambda using SNS topics.
Send email reports or alerts from automation flows using Python scripts.
Send key deployment and monitoring alerts to Teams.
Sentiment Analysis
Serve ASGI apps (FastAPI, Starlette) with high performance using Uvicorn.
Serve WSGI applications in production with Python using Gunicorn.
Serve low-latency features to ML endpoints using SageMaker Feature Store.
Serve models via endpoints or batch prediction jobs using key Vertex AI.
Serve static content and cache responses efficiently using Nginx.
Serve web apps and static sites using Apache HTTP Server using Apache.
Set alarms for services like Lambda and Glue using CloudWatch Metrics.
Set key alarms for CPU, memory, or failures in CloudWatch.
Set key alerts and integrate with GCP services via Stack.
Set key alerts and share insights with teams via Kibana.
Set key alerts and thresholds for KPIs using Grafana tools.
Set key alerts using Alertmanager integration with Prometheus.
Set key dashboards and anomaly detection rules in Datadog.
Set retention, filters, and alerts using CloudWatch Logs.
Set up GitHub-based auto-builds in Docker Hub easily.
Set up cross-service permissions and trust with IAM roles.
Set up custom domains, HTTPS, and autoscaling easily using Render.
Set up key workflows for bug fixes and release cycles.
Set up local and Docker environments for testing weaviate vector DB.
Share secure data across accounts and clouds using key Snowflake.
Shell script
Simplify UI features like pagination and modals using HTMX.
Simplify developer onboarding with prebuilt dev environments using Docker.
Simulate user actions and page navigation programmatically using Playwright.
Slack
Snowball
Snowflake
Solve planning problems using AI decision-making models.
Solve real-world problems using Python data science tools.
SonarQube
Sort and group Python imports consistently using isort.
Spark Streaming
Speed up deep learning using GPU/TPU accelerators.
Speed up environment creation compared to venv using virtualenv.
Speed up serving with ONNX Runtime in production APIs.
Spin up full stacks with a single `docker-compose up` using Docker Compose.
Spin up key Docker containers for isolated test runs.
Split and validate data for ML experiments properly.
Standardize data types and formats during cleaning.
Start services with a single command for local development using Docker Compose.
Step Functions
Store access tokens, rate limits, and session data using Redis backend tools.
Store and retrieve embeddings using Weaviate, Chroma, or Qdrant DBs.
Store and rotate key secrets securely via Secrets Manager.
Store charts in Helm repositories using Helm.
Store files on HDFS in Hadoop-based ETL pipelines.
Store key secrets as encrypted YAML/ENV files via SOPS.
Store key values like DB creds securely in Kubernetes Secrets.
Store raw, curated, and processed datasets at scale using Data Lake.
Store/manage key secrets, tokens, and certs via Vault tool.
Stored and queried document embeddings using Qdrant REST API.
Stored chunked documents in vectordb Chroma for fast lookup.
Stored sentence embeddings in vectordb (Weaviate, Chroma, Qdrant).
Stream CDC and real-time events into storage using key Apache Hudi.
Stream key logs to ELK, Loki, and cloud tools reliably.
Stream processing with Kafka Streams or ksqlDB using Kafka.
Stream real-time Kafka or Kinesis data using Spark Streaming.
Supervised Learning
Support Docker, Kubernetes, and AWS integrations using Jenkins plugins using Jenkins.
Support PHP, CGI, and custom modules in legacy stacks using Apache.
Support Redis as a backend for distributed rate limiting using FastAPI throttle.
Support advanced logic in templates for web apps using Mako.
Support hot reload for local development using Uvicorn.
Support image, signal, and matrix processing using NumPy.
Support key input/output sources like Beats, Kafka, files.
Support key login for social or multi-tenant users.
Support key test stacks in Java, Node.js, or Python.
Support line-by-line or full-file formatting using autopep8.
Support local development workflows without external tools using venv.
Support parallel reads and analytics with Spark or Presto using Data Lake.
Support real-time updates with WebSockets and Django Channels using Vue.
Support reporting dashboards and large-scale queries using key Presto.
Support reusable shell scripts for environment setup using virtualenv.
Support schema evolution and audit trails in pipelines using key Delta Lake.
Switch Python versions flexibly within a project using pipenv.
Switch profiles and variables across environment stages.
TPU
Take screenshots or collect logs for debugging using Selenium.
Tecton
Templatize deployments with dynamic values using Helm.
TensorFlow
Terraform
Test CDK code with unit assertions for infrastructure logic.
Test Flask APIs with tools like Postman or Pytest.
Test and debug scripted models before production with TorchScript.
Testcontainers
Throttle requests and rotate user agents/middleware using Scrapy.
Throttle requests per IP or token to prevent abuse using FastAPI throttle.
Tokenization
TorchScript
Tortoise ORM
Trace distributed apps and Lambda flows using X-Ray.
Track AWS API calls and user activity using CloudTrail.
Track AWS metrics like CPU, memory, and I/O using CloudWatch Metrics.
Track Snowball job status and logs using AWS Console tools.
Track feature access, drift, and history using SageMaker Feature Store.
Track image usage and stats directly via Docker Hub.
Track image versions and audit logs in Google GCR.
Track key auth events for access and config activity logs.
Track key changes via `terraform plan` and `apply` flows.
Track key config changes across AWS resources with Config.
Track key issues, PRs, and workflows in GitHub boards.
Track key issues, milestones, and boards in GitLab.
Track key metrics via Stackdriver Monitoring in GCP.
Track key secret versions securely using SOPS in Git.
Track key security, uptime, and performance trends fast.
Track key system health and errors via Kibana insights.
Track key tasks via calendar or timeline Trello views.
Track key uptime, errors, and latency trends visually.
Track key usage and access audits using KMS + CloudTrail.
Track key work with issues, sprints, and epic views.
Track lineage and monitor usage of features using Feast.
Track metadata and lineage of data assets with key Dagster tooling.
Track pipeline health and metrics using Dataflow UI using key Dataflow.
Track versioned, testable models with dbt and Git.
Train
Train ML models like SVM and random forest using scikit-learn.
Train ML models using Python libraries like XGBoost.
Train Neural Network to recognize handwritten digits.
Train agents using Reinforcement Learning in simulators.
Train and deploy ML models using AutoML or custom pipelines using key Vertex AI.
Train and deploy machine learning models at scale using Azure ML.
Train and tune neural networks on large datasets using TensorFlow.
Train models on GPU using AWS SageMaker notebooks.
Train models on GPU using efficient APIs provided by PyTorch.
Train predictive models with Python for data science use.
Train random forest for feature-rich classification tasks.
Train supervised models in machine learning pipelines.
Transfer large datasets to AWS securely using Snowball devices.
Transform data using DataFrame and SQL APIs in PySpark.
Transform messy inputs using Python preprocessing code.
Transform timestamps or text for feature engineering use.
Transformed business rules into a physical data model.
Trello
Trigger Azure ML and Databricks jobs from pipelines using Data Factory.
Trigger Glue, Lambda, and S3 jobs programmatically with Boto3.
Trigger Lambda from S3, API Gateway, or CloudWatch events using Lambda.
Trigger Spark or SQL jobs via CLI using Shell script.
Trigger builds on Git push, PR, or scheduled events using Jenkins.
Trigger event-driven workflows from API Gateway or EventBridge using key Step Functions.
Trigger key alerts based on thresholds or behaviors tracked.
Trigger serverless functions on events like file uploads or Pub/Sub using key Cloud Functions.
Trigger workflows based on event rules using SNS.
Trigger workflows via S3 events linked to Lambda functions.
Troubleshoot app issues with CloudWatch Logs and metrics.
Tune EMR cluster configs for better performance and reliability.
Tune accuracy with Hyperparameter Tuning methods.
Tune database parameters for better performance using RDS.
Tune hyperparameters to boost ML model performance.
Tune key queries and indexing performance in Elasticsearch.
Tune model hyperparameters with GridSearchCV in scikit-learn.
Unify key logs, metrics, and traces in one Stackdriver UI.
Unit
Unsupervised Learning
Updated the data model to support new business KPIs.
Use ALB for load balancing and discovery in ECS services.
Use Apache as a reverse proxy or load balancer for backend services using Apache.
Use AutoML and hyperparameter tuning for faster results using Azure ML.
Use BatchWriteItem and BatchGetItem for bulk ops in DynamoDB.
Use Boto3 paginators to manage large AWS API responses.
Use CDC techniques for real-time data sync across systems.
Use CDK constructs to simplify reusable stack components.
Use CloudFormation, ECS, and EKS for application deployment using cloud.
Use CloudTrail logs for security audits and compliance.
Use CloudWatch Metrics for auto-scaling and alerts.
Use Cross-validation to validate model generalization.
Use Cross-validation to validate models generalization.
Use Django Admin for CRUD and internal tooling using Django.
Use Docker Compose to orchestrate multi-container apps using Docker.
Use Docker Hub in CI/CD pipelines for fast deployment.
Use DynamoDB Streams with Lambda for real-time processing.
Use ECR with ECS or Lambda deployments seamlessly.
Use EMRFS consistent view for reliable S3 data interactions.
Use Elasticsearch for key analytics and observability apps.
Use Flask with Gunicorn or uWSGI for production scaling.
Use Flask-CORS to manage cross-origin requests easily.
Use Fluent Bit for key edge log forwarding and parsing.
Use Fluentd plugins for key integrations with outputs.
Use Git-based deployment and buildpacks for CI/CD using Heroku.
Use GitHub Actions for MLOps model retraining flow.
Use GitLab CI for canary, rollback, and multi-env deployment using GitLab CI.
Use Google GCR with GKE or Cloud Build for CI/CD.
Use Gunicorn behind Nginx for scalable deployment using Gunicorn.
Use HTML attributes to bind backend endpoints to frontend events using HTMX.
Use Hive with Hadoop for SQL-like queries on big data.
Use Hugging Face Transformers to build production-grade NLP apps.
Use IAM for federated access with external identity providers.
Use Java SDKs to connect with AWS services and databases.
Use Jinja and macros to create reusable logic in dbt.
Use Kafka Connect on MSK to integrate external data sources.
Use Keras API for rapid prototyping and experimentation using TensorFlow.
Use LangChain or Haystack to orchestrate LLM and embedding flows.
Use Maven Central via Artifactory or Nexus proxy.
Use Nginx as a reverse proxy for backend APIs using Nginx.
Use NumPy arrays for data preprocessing in ML workflows.
Use NumPy to generate random numbers and distributions.
Use ONNX to bridge training and serving model formats.
Use Pandas for cleaning and prep in Data Analytics tasks.
Use Pandas for handling missing data during cleaning.
Use Pandas for time series resampling and rolling windows.
Use Pandas to explore data with head(), describe(), and info().
Use Poetry in CI/CD for reliable installs and versioning using Poetry.
Use Prometheus and Grafana for monitoring EKS clusters.
Use PyPI metadata for versioning and compatibility.
Use PySpark for parallel data engineering processing.
Use PyTorch for fast prototyping with dynamic computation graphs.
Use PyTorch for training deep AI models efficiently.
Use Python for domain-based feature engineering logic.
Use Python to reshape and flatten data in transformation.
Use QuickSight SPICE for fast, in-memory data analytics.
Use RDS parameter groups to control DB engine behavior.
Use RNN models to predict next words in a sentence.
Use Redis for fast in-memory caching in Python apps using Redis backend tools.
Use Redis or RabbitMQ as a message broker backend using Celery.
Use Redshift COPY to load and transform S3 data efficiently.
Use Redshift Spectrum to query S3 without copying the data.
Use SQL SELECT statements to extract data from tables.
Use SQL aliases to simplify column and table names.
Use SQLite, PostgreSQL, or MySQL backends seamlessly using Tortoise ORM.
Use SSIS for ETL and data migrations with SQL Server.
Use Sentiment Analysis to flag negative comments.
Use SerDe and write custom UDFs for formats in HiveQL.
Use Snowball Edge and CLI to automate data extraction tasks.
Use Snowpipe for near real-time ingestion from streams using key Snowflake.
Use Supervised Learning to classify customer behavior.
Use TPU for fast training of large language models.
Use TensorFlow for computer vision, NLP, and time series tasks.
Use Tokenization to split text into words for NLP.
Use TorchScript to boost model execution speed.
Use Unsupervised Learning to cluster user segments.
Use Vue CLI or Vite for local dev and builds using Vue.
Use YAML to configure services, volumes, and networks using Docker Compose.
Use `.env` or secrets managers for each environment config.
Use alongside flake8 for fix-and-check workflows using autopep8.
Use auto-deploy from Git repositories for CI/CD using Render.
Use broadcasting and vectorized operations for speed using NumPy.
Use caching and batching to manage large datasets.
Use caching and parallel jobs to speed up builds using CircleCI.
Use config options to define custom sorting logic using isort.
Use cross-validation for robust ML predictions.
Use data mining to generate actionable business insights.
Use decision trees or SVMs in Python classification tasks.
Use declarative definitions for reusable ML features using Tecton.
Use decorators to register functions as scheduled tasks using APScheduler.
Use distributed computing for BigData performance gains.
Use dynamic computation graphs for research workflows using PyTorch.
Use early stopping and CV to tune models in XGBoost.
Use enhanced fan-out for parallel data consumption using Kinesis.
Use envelope encryption for better performance with KMS.
Use environment variables and IAM for secure configuration using Lambda.
Use fan-out pattern to notify multiple targets with SNS.
Use grid search for Hyperparameter Tuning models.
Use groupby and pivot with Pandas for analytics workflows.
Use in conjunction with cron jobs for scheduling using Bash.
Use key Git hooks for automation, lint, and security.
Use key IdPs like Azure AD or Okta for SSO setup.
Use key annotations like @Test and @Before in Unit tests.
Use key audit trails for compliance and threat detection.
Use key bots, flows, and apps via Power Automate flows.
Use key decryption automation in CI/CD via SOPS support.
Use key dynamic secrets for DBs, APIs using Vault engines.
Use key fixtures for setup and teardown in pytest tests.
Use key integrations for AWS, GCP, Azure, Kubernetes, etc.
Use key nested stacks for modular infra provisioning.
Use key secrets in Lambda, ECS, RDS with AWS integration.
Use key slash commands and bots for automation in Slack.
Use key workspaces for prod/dev/test separation in Terraform.
Use lazy execution and parallelism with Polars for ETL.
Use libraries like Authlib, PyJWT, or FastAPI JWT Bearer using JWT.
Use local and remote repositories via JFrog Artifactory.
Use npm in CI pipelines for auto version publishing.
Use partitioning and projection to speed up Athena queries.
Use pipenv in CI workflows for consistent environments using pipenv.
Use pre-trained transformer models like BERT for NLP tasks.
Use pylint plugins for Django, Flask, or type hints using pylint.
Use random forest to handle missing and noisy data cases.
Use read replicas in Aurora to scale read-heavy workloads easily.
Use reusable templates and parameterized stacks in deployment.
Use scikit-learn to deploy models in Python applications.
Use scikit-learn, TensorFlow in data science workflows.
Use standard libraries like Authlib and Allauth for rapid setup using OAuth.
Use state management libraries like Redux or Context API using React.
Use template inheritance and custom filters using Mako.
Use template inheritance with blocks and macros using Jinja2.
Use time travel for versioned access to data history using key Delta Lake.
Use unsupervised ML for clustering and anomalies.
Use venv as a lightweight tool bundled with Python using venv.
Use volumes and networks for inter-container communication using Docker Compose.
Use watermarks and event-time semantics for accuracy using Apache Flink.
Use windowed operations and time-based joins in Spark Streaming.
Use with VSCode for real-time feedback on types using pyright.
Use with virtualenvwrapper for advanced workflows using virtualenv.
Used Git to version control and manage Python scripts.
Used GraphQL for database integration with SQL and NoSQL database.
Used Neo4j to store and query GrapghDB data.
Used Neo4j to store and query graph-based data.
Used NoSQL key-value and document data models to handle flexible, schema-less data.
Used Python lists and dicts for efficient data operations.
Used decorators and closures in Python for custom behavior.
Used vector databases with Generative AI for semantic search.
Used vectordb Chroma to experiment with sentence-transformers models.
Used vectordb Chroma to test embedding-based question answering.
Used vectordb to implement hybrid search with metadata filters.
Used weaviate to combine BM25 keyword and vector-based search efficiently.
Utilize distributed training strategies for large models using TensorFlow.
Uvicorn
Validate data consistency with SQL constraints and keys.
Validate data quality and schema expectations using Great Expectations.
Validate infrastructure changes before deployment.
Validate inputs and outputs with Pydantic models using FastAPI.
Validate large Python projects with strong typing using pyright.
Validated the data model with sample datasets and tests.
Vercel
Version and manage DAGs with Git for CI/CD in Airflow.
Vertex AI
View key logs, traces, and metrics all in one New Relic UI.
View key resource history and drift with AWS Config.
Visualize insights using Pandas in Data Analytics projects.
Visualize job status, logs, and history in Blue Ocean UI using Jenkins.
Visualize key Elastic data using charts and dashboards.
Visualize key code coverage and maintainability metrics.
Visualize key metrics from Prometheus, Loki, CloudWatch etc.
Visualize key team progress with Agile boards and charts.
Visualize large or streaming datasets in real-time using Bokeh.
Visualize latency and call graphs using X-Ray UI.
Visualize patterns from Kaggle datasets with Matplotlib.
Visualize pipeline stages and job logs in GitLab UI using GitLab CI.
Visualize pipeline status with built-in monitoring dashboards using Data Factory.
Visualize time series, scatter plots, and 3D charts using Plotly.
Visualize trends and metrics in analytics using Pandas.
Visualize trends, comparisons, and distributions using matplotlib.
Visualize trends, distributions, and correlations in datasets using seaborn.
Vue
Work with NULL values and SQL COALESCE/ISNULL functions.
Work with filesystem paths in an object-oriented way using pathlib.
Worked with AWS DynamoDB, a fast and serverless NoSQL database for scalable applications.
Worked with Python data types like int, str, list, and dict.
Worked with message queues as a backend developer using RabbitMQ and Kafka.
Write Dockerfiles to define base image, dependencies, and commands using Docker.
Write and manage reproducible builds with Dockerfiles using Docker.
Write and update data via Spark, Flink, or Hive using key Iceberg.
Write complex queries using QuerySet chaining using Django ORM.
Write custom UDFs in Hive or Spark for data tasks using Java.
Write install and setup automation using Shell script.
Write key HCL modules for reusable infra automation code.
Write key unit and integration tests using pytest in Python.
Write key unit tests for Java code using JUnit methods.
Write key unit tests for validating OPA policy logic.
Write modular SQL models to transform raw data in key DBT pipelines.
Write modular scripts with CLI and error handling using Python scripts.
Write nested SQL queries for complex data retrieval.
Write optimized SQL queries for data analysis and transformation tasks.
Write output to S3 or Redshift using Spark Streaming jobs.
Write raw SQL for complex use cases when needed using SQLAlchemy.
Write shell scripts for automation, deployment, and system tasks using Bash.
Write stateless functions for microservice tasks using Lambda.
Wrote Cypher queries to fetch and analyze graph data.
Wrote Python lambda and list, dict comprehensions for clean code.
Wrote Python unit tests to validate function logic and output.
Wrote unit and integration tests as a backend developer to ensure code quality.
X-Ray
XGBoost
analytics
architect
architecture
autopep8
black
bullet_points
cleaning
cloud
conda
data engineer
data engineering
data mining
data science
database integration
datasets
dbt
deployment
environment
feature engineering
flake8
hadoop
isort
machine learning
matplotlib
multi-modal
mypy
nodejs
npm
os
pathlib
pip
pipenv
preprocessing
pylint
pyright
pytest
scikit-learn
seaborn
shutil
subset
time-series
timeseries
transformation
vectordb
venv
virtualenv
weaviate
zero-shot/few-shot
